<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Screenboard</title>
    <script src="https://craig.global.ssl.fastly.net/js/mousetrap/mousetrap.min.js?a4098"></script>

    <style>
      *,
      button,
      input {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100vh;
      }

      html {
        background-color: transparent;
        overflow: hidden;
      }

      body {
        background-color: rgba(255, 255, 255, 0.001);
        cursor: none;
      }

      canvas {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // Creating Canvas
      const ctx = canvas.getContext("2d")
      let backgroundColor = "transparent"

      // Size of the canvas is the same defined in CSS
      window.addEventListener("load", () => {
        canvas.width = canvas.offsetWidth
        canvas.height = canvas.offsetHeight
        canvas.style.background = backgroundColor
      })

      // Tools
      const tools = new Map()
      tools.set("rectangle", (e) => {
        ctx.strokeRect(
          e.offsetX,
          e.offsetY,
          prevMouseX - e.offsetX,
          prevMouseY - e.offsetY
        )
      })

      tools.set("brush", (e) => {
        ctx.lineTo(e.offsetX, e.offsetY)
        ctx.stroke()
      })

      tools.set("circle", (e) => {
        ctx.beginPath() // new path to draw the circlec
        let radius = Math.sqrt(
          Math.pow(prevMouseX - e.offsetX, 2) +
            Math.pow(prevMouseY - e.offsetY, 2)
        )

        ctx.arc(prevMouseX, prevMouseY, radius, 0, 2 * Math.PI)
        ctx.stroke()
      })

      tools.set("eraser", (e) => {
        ctx.strokeStyle = backgroundColor
        ctx.lineTo(e.offsetX, e.offsetY)
        ctx.stroke()
      })

      tools.set("line", (e) => {
        const currentPosition = {
          x: e.clientX - canvas.offsetLeft,
          y: e.clientY - canvas.offsetTop,
        }

        const line = {
          start: mouseDownPosition,
          end: currentPosition,
        }

        ctx.beginPath()
        ctx.moveTo(line.start.x, line.start.y)
        ctx.lineTo(line.end.x, line.end.y)
        ctx.stroke()
      })

      // Controls
      let prevMouseX,
        prevMouseY,
        snapshot,
        mouseDownPosition,
        isDrawing = false,
        currentTool = "line",
        currentColor = "red",
        brushSize = 3

      const setCurrentTool = (tool) => (currentTool = tool)
      const setCurrentColor = (color) => {
        currentColor = color
        customCursor()
      }
      const undo = () => history.undo(restoreHistory)
      const redo = () => history.redo(restoreHistory)
      const save = () => history.save()
      const clear = () =>
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
      const increase = () => ++brushSize
      const decrease = () => (brushSize = brushSize <= 0 ? 1 : --brushSize)

      // Shortcuts
      Mousetrap.bind("w", () => setCurrentTool("rectangle"))
      Mousetrap.bind("r", () => setCurrentTool("circle"))
      Mousetrap.bind("e", () => setCurrentTool("brush"))
      Mousetrap.bind("t", () => setCurrentTool("eraser"))
      Mousetrap.bind("q", () => setCurrentTool("line"))
      Mousetrap.bind("a", () => setCurrentColor("red"))
      Mousetrap.bind("s", () => setCurrentColor("green"))
      Mousetrap.bind("d", () => setCurrentColor("blue"))
      Mousetrap.bind("f", () => setCurrentColor("black"))
      Mousetrap.bind("g", () => setCurrentColor("white"))
      Mousetrap.bind("mod+z", () => undo())
      Mousetrap.bind("mod+y", () => redo())
      Mousetrap.bind("mod+backspace", () => clear())
      Mousetrap.bind("=", () => increase())
      Mousetrap.bind("-", () => decrease())

      // Actions
      const startDraw = (e) => {
        isDrawing = true
        prevMouseX = e.offsetX
        prevMouseY = e.offsetY
        ctx.beginPath() // new path to draw
        ctx.lineWidth = brushSize
        ctx.strokeStyle = currentColor

        mouseDownPosition = {
          x: e.offsetX - canvas.offsetLeft,
          y: e.offsetY - canvas.offsetTop,
        }

        //copy canvas data as snapshot value
        snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height)
        drawing(e)
      }

      const stopDraw = () => {
        isDrawing = false
        save()
      }

      const drawing = (e) => {
        if (!isDrawing) return

        // add copied canvas data on to this canvas
        ctx.putImageData(snapshot, 0, 0)

        const draw = tools.get(currentTool)
        draw(e)
      }

      canvas.addEventListener("mousedown", startDraw)
      canvas.addEventListener("mouseup", stopDraw)
      canvas.addEventListener("mousemove", drawing)

      /**
       * SimpleUndo is a very basic javascript undo/redo stack for managing histories of basically anything.
       *
       * options are: {
       * 	* `provider` : required. a function to call on `save`, which should provide the current state of the historized object through the given "done" callback
       * 	* `maxLength` : the maximum number of items in history
       * 	* `onUpdate` : a function to call to notify of changes in history. Will be called on `save`, `undo`, `redo` and `clear`
       * }
       *
       */

      class SimpleUndo {
        constructor(options) {
          const settings = options ? options : {}
          const defaultOptions = {
            provider: function () {
              throw new Error("No provider!")
            },
            maxLength: 30,
            onUpdate: function () {},
          }

          this.provider =
            typeof settings.provider != "undefined"
              ? settings.provider
              : defaultOptions.provider
          this.maxLength =
            typeof settings.maxLength != "undefined"
              ? settings.maxLength
              : defaultOptions.maxLength
          this.onUpdate =
            typeof settings.onUpdate != "undefined"
              ? settings.onUpdate
              : defaultOptions.onUpdate

          this.initialItem = null
          this.clear()
        }

        initialize(initialItem) {
          this.stack[0] = initialItem
          this.initialItem = initialItem
        }

        clear() {
          this.stack = [this.initialItem]
          this.position = 0
          this.onUpdate()
        }

        truncate(stack, limit) {
          while (stack.length > limit) {
            stack.shift()
          }
        }

        save() {
          this.provider((current) => {
            if (this.position >= this.maxLength)
              this.truncate(this.stack, this.maxLength)

            this.position = Math.min(this.position, this.stack.length - 1)
            this.stack = this.stack.slice(0, this.position + 1)
            this.stack.push(current)
            this.position++
            this.onUpdate()
          })
        }

        undo(callback) {
          if (!this.canUndo()) return

          const item = this.stack[--this.position]
          this.onUpdate()

          if (!callback) return
          callback(item)
        }

        redo(callback) {
          if (!this.canRedo()) return

          const item = this.stack[++this.position]
          this.onUpdate()

          if (!callback) return
          callback(item)
        }

        canUndo() {
          return this.position > 0
        }

        canRedo() {
          return this.position < this.count()
        }

        count() {
          return this.stack.length - 1 // -1 because of the initial item
        }
      }

      /**
       * Undo and redo drawed lines
       */
      const history = new SimpleUndo({
        provider: (done) => done(canvas.toDataURL("image/png")),
      })

      const restoreHistory = (image) => {
        if (!image) {
          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
          return
        }
        // criar imagem e colocar no canvas
        const img = new Image()
        img.onload = () => {
          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
          ctx.drawImage(img, 0, 0)
        }

        img.src = image
      }

      //custom cursor
      const customCursor = () => {
        let svg = `
		<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" 
    xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
		width="48px" height="64px" viewBox="0 0 528.899 528.899" 
		style="enable-background:new 0 0 32 32; fill: ${currentColor}; transform: rotate(90deg) translate(6px, 8px) scale(.6)"
		xml:space="preserve">
   		<g>
			<path d="M328.883,89.125l107.59,107.589l-272.34,272.34L56.604,361.465L328.883,89.125z M518.113,63.177l-47.981-47.981
				c-18.543-18.543-48.653-18.543-67.259,0l-42.495,77.559,518.113,63.177z M0.3,512.69c-1.958,8.812,5.998,16.708,14.811,14.565l119.891-29.069
				L27.473,390.597L0.3,512.69z"/></g><g></g><g></g><g></g>
		<g>5.961,45.961l107.59,107.59l53.611-53.611
				C532.495,100.753,53
		</g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`

        svg = encodeURIComponent(svg.replace(/"/g, "'"))

        // let svgRule = `.drawing-board-canvas { cursor: url("data:image/svg+xml,${svg}") 0 24, crosshair; }`;
        canvas.style.cursor = `url("data:image/svg+xml,${svg}") 0 24, crosshair`
        console.log(canvas.style)
      }
      customCursor()
    </script>
  </body>
</html>
